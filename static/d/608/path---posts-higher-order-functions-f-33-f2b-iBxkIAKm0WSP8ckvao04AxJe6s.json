{"data":{"markdownRemark":{"frontmatter":{"title":"Higher Order Functions","date":"May 10th, 2018","image":{"childImageSharp":{"fluid":{"src":"/static/805b8e3c5424dbffbe9a2108bbb66e45/bc3a8/hoc-header-LG.jpg","srcSet":"/static/805b8e3c5424dbffbe9a2108bbb66e45/d278e/hoc-header-LG.jpg 200w,\n/static/805b8e3c5424dbffbe9a2108bbb66e45/8539d/hoc-header-LG.jpg 400w,\n/static/805b8e3c5424dbffbe9a2108bbb66e45/bc3a8/hoc-header-LG.jpg 800w,\n/static/805b8e3c5424dbffbe9a2108bbb66e45/81ef8/hoc-header-LG.jpg 1200w,\n/static/805b8e3c5424dbffbe9a2108bbb66e45/f6605/hoc-header-LG.jpg 1248w","tracedSVG":"data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' width='400' height='109'%3e%3cpath d='M0 55v54h401V0H0v55m177-36l1 43 23 1h22V17h-23c-21 0-23 0-23 2m21 29c0 8-2 10-4 7-3-3-5-1-3 2 2 4 6 4 9 1s3-16 0-17c-2 0-2 1-2 7m10-6l-2 4c0 3 1 3 5 5 3 1 5 3 5 4 0 2-5 1-7-1-2-1-4-1-4 1s4 5 6 5c10 1 12-8 3-12-3 0-5-2-5-2 1-2 6-2 6-1l2 1c2 0 3-1 0-3-1-2-7-2-9-1m-18 33c0 2-1 3-3 3-3 0-4 1-4 5s1 6 6 6h3v-8l-1-8-1 2m-30 1c-3 6 1 14 7 13 5-2 7-10 3-13-2-3-9-3-10 0m-48 2c-2 0-3 3-2 4v7c-2 3 0 4 3 4 7 0 9-5 2-6-4 0-4-1 0-3 3-1 3-1 3-3v-2l1-1h-7' fill='%23d3d3d3' fill-rule='evenodd'/%3e%3c/svg%3e","aspectRatio":3.6705882352941175}}},"intro":null},"html":"<p>A post that tries to help demystify how higher order functions work by looking at ones you probably already use.</p>\n<p>When you first see higher order functions and how they were written it can feel a little intimidating especially if you're not fully acclimated to es6 syntax. Reading that they're \"functions that return functions\", \"functions that modify other functions\", \"functions that accept functions as arguments\" seeing code like <code>isLessThan = x => y => y &#x3C; x;</code> or <code>isLessThan(a)(b)</code>.</p>\n<p>What some people don't realise is that they're probably already using higher order functions, the Array primitive has some higher order methods like <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map\">map</a>, <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter\">filter</a> and <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/Reduce\">reduce</a> which are commonly used to manipulate lists in front end frameworks.</p>\n<p>If you have used some of these you may have even combined them like this trivial example that returns a list of female user emails</p>\n<pre><code class=\"language-javascript\">const femEmailList = myUsers.filter(usr => user.gender === 'female')\n  .map(femUsr => femUsr.email);\n</code></pre>\n<p>This is known as function composition where the result of one function becomes the input of the next and so on, this is a core concept in functional programming and allows you to compose smaller functions into bigger ones.</p>\n<p>Let's go one step further, I often find the easiest way to learn how something works is to take it apart and analyse it piece by piece, so lets rebuild these methods and replicate how they work.</p>\n<h3>map</h3>\n<p>This method is a pure function that iterates through an array and returns a new array, it takes a function for the first argument which it calls with each item in the array and returns a new array with the functions results, confusing? take a look at the example below.</p>\n<p>You may have a list of user objects that you need to get email addresses from, lets get an array of user emails with map:</p>\n<pre><code class=\"language-javascript\">const emailList = myUsers.map(user => user.email);\n</code></pre>\n<p>map is part of the array prototype which means any array will have this method available to it but lets recreate the functionality of map in a custom function called \"iDesignMap\".</p>\n<pre><code class=\"language-javascript\">const iDesignMap = arrayToMap => funcToRun => {\n  let newArray = [];\n  for (let i = 0; arrayToMap.length > i; i++) {\n    newArray.push(funcToRun(arrayToMap[i], i, arrayToMap));\n  }\n  return newArray;\n};\n\nconst emailList = iDesignMap(myUsers)(user => user.email);\n</code></pre>\n<p>This may look complicated at first but just concentrate at the bottom where \"iDesignMap\" is called.\nIn functional programming languages functions are values, we assign the function \"iDesignMap\" to the constant \"emailList\". \"iDesignMap\" takes an array \"myUsers\" and returns a function (itself) that takes another function <code>user => user.email</code> as an argument which is uses internally to return a new array.</p>\n<p>\"iDesignMap\" iterates over the array \"arrayToMap\" and calls \"funcToRun\" with each value, index and the original array. The returned result gets pushed into a new array which gets returned at the end.</p>\n<p>Another common use case is where you take an array of data and map to DOM elements, for example you may want to display a list of comments in React for example it would look like this.</p>\n<pre><code class=\"language-javascript\">render() {\n  const { comments } = this.props;\n  return (\n    &#x3C;ul>\n      {comments.map(comment => (\n        &#x3C;li>{comment.body}&#x3C;/li>\n      )}\n    &#x3C;/ul>\n  );\n}\n</code></pre>\n<p>{% include article-adsense.html %}</p>\n<h3>filter</h3>\n<p>Filter although similar to map is critically different as it returns a new filtered version of the original array rather than transforming each value.</p>\n<pre><code class=\"language-javascript\">const maleUsers = myUsers.filter(user => user.gender === 'male');\n</code></pre>\n<p>The function argument must return a boolean, if it returns true for that array item it will be returned in the new array.</p>\n<p>Lets recreate filter as a custom function.</p>\n<pre><code class=\"language-javascript\">const iDesignFilter = arrayToMap => funcToRun => {\n  let newArray = [];\n  for (let i = 0; arrayToMap.length > i; i++) {\n    if (funcToRun(arrayToMap[i], i, arrayToMap)) {\n      newArray.push(arrayToMap[i]);\n    }\n  }\n  return newArray;\n};\n\nconst isMale = user => user.gender === 'male';\nconst maleUsers = iDesignFilter(myUsers)(isMale);\n</code></pre>\n<p>\"iDesignFilter\" takes an array \"arrayToMap\" and returns a function that takes another function \"funcToRun\" as an argument, when \"iDesignFilter\" iterates over \"arrayToMap\" it calls \"funcToRun\" with each value, index and the original array then finally returns a new filtered array.</p>\n<h3>It still doesn't look right...</h3>\n<p>The main difference between these custom functions and the native counterparts is that the custom functions are not part of the array prototype and therefore must be passed the array, however you can add them to the prototype and use \"this\" in place of \"arrayToMap\".</p>\n<pre><code class=\"language-javascript\">Array.prototype.iDesignFilter = function(funcToRun) {\n  let newArray = [];\n  for (let i = 0; this.length > i; i++) {\n    if (funcToRun(this[i], i, this)) {\n      newArray.push(this[i]);\n    }\n  }\n  return newArray;\n  }\n\n  var maleUsers = myUsers.iDesignFilter(user => user.gender === 'male');\n</code></pre>\n<p>After you add this method to the prototype it will be available to all Array types just like \"map\" and \"filter\".\nOf course this example is trivial because the methods already exist but now you can understand how higher order functions work, where they are used and how they are integrated into the language already.</p>"}},"pageContext":{"isCreatedByStatefulCreatePages":false,"slug":"higher-order-functions"}}